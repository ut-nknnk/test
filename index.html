<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ポーカー オープンポジション クイズ (40bb) - カード表示版</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Tailwind gray-900 */
            color: #e2e8f0; /* Tailwind slate-200 */
            padding-top: 1rem;
            padding-bottom: 1rem;
        }
        .main-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
        }
        @media (min-width: 1024px) { /* lg breakpoint */
            .main-container {
                flex-direction: row;
                align-items: flex-start;
                justify-content: center;
            }
        }
        .quiz-panel-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 500px; /* Max width for quiz and chart */
        }
        .quiz-panel {
            background-color: #2d3748; /* Tailwind gray-800 */
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            text-align: center;
            padding: 1.5rem;
            width: 100%;
        }
        @media (min-width: 640px) { /* sm breakpoint */
            .quiz-panel {
                padding: 2rem;
            }
        }
        /* Updated .card-display style */
        .card-display {
            margin-bottom: 1.5rem;
            min-height: 7rem; /* Accommodate card height (h-24 is 6rem) + padding */
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .btn-action {
            transition: all 0.2s ease-in-out;
            border-width: 2px;
            border-style: solid;
            font-weight: 600;
            padding: 0.6rem 0.8rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06);
            font-size: 0.875rem;
            min-width: 55px;
         }
        .btn-action:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -2px rgba(0,0,0,0.05);
        }
        /* Position Button and Chart Cell Styles */
        .pos-utg, .btn-pos-utg { background-color: #dc2626; border-color: #b91c1c; color: white; } /* Red */
        .pos-utg:hover:not(:disabled), .btn-pos-utg:hover:not(:disabled) { background-color: #b91c1c; }
        .pos-utgplus1, .btn-pos-utgplus1 { background-color: #f97316; border-color: #ea580c; color: white; } /* Orange */
        .pos-utgplus1:hover:not(:disabled), .btn-pos-utgplus1:hover:not(:disabled) { background-color: #ea580c; }
        .pos-mp, .btn-pos-mp { background-color: #eab308; border-color: #ca8a04; color: #1a202c; } /* Yellow */
        .pos-mp:hover:not(:disabled), .btn-pos-mp:hover:not(:disabled) { background-color: #ca8a04; }
        .pos-hj, .btn-pos-hj { background-color: #22c55e; border-color: #16a34a; color: white; } /* Green */
        .pos-hj:hover:not(:disabled), .btn-pos-hj:hover:not(:disabled) { background-color: #16a34a; }
        .pos-co, .btn-pos-co { background-color: #0ea5e9; border-color: #0284c7; color: white; } /* Sky Blue */
        .pos-co:hover:not(:disabled), .btn-pos-co:hover:not(:disabled) { background-color: #0284c7; }
        .pos-btn, .btn-pos-btn { background-color: #a855f7; border-color: #9333ea; color: white; } /* Purple */
        .pos-btn:hover:not(:disabled), .btn-pos-btn:hover:not(:disabled) { background-color: #9333ea; }
        .pos-fold, .btn-pos-fold { background-color: #6b7280; border-color: #4b5563; color: white; } /* Gray */
        .pos-fold:hover:not(:disabled), .btn-pos-fold:hover:not(:disabled) { background-color: #4b5563; }
        .btn-reset { background-color: #facc15; border-color: #eab308; color: #1f2937; } /* Yellow */
        .btn-reset:hover:not(:disabled) { background-color: #d69e2e; }
        .btn-reveal-all {
            background-color: #4b5563;
            border-color: #374151;
            color: white;
            font-size: 0.75rem;
            padding: 0.4rem 0.6rem;
         }
        .btn-reveal-all:hover:not(:disabled) { background-color: #374151; }

        .feedback-correct { color: #22c55e; } /* Green-500 */
        .feedback-incorrect { color: #ef4444; } /* Red-500 */
        .feedback-neutral { color: #3b82f6; } /* Blue-500 */
        .score-board {
            background-color: #4b5563; /* Tailwind gray-600 */
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: inset 0 2px 4px 0 rgba(0,0,0,0.06);
            font-size: 0.875rem;
        }
        .score-board p span { font-weight: 600; }
        .disabled-button { opacity: 0.5; cursor: not-allowed; }
        .next-hand-btn { background-color: #a855f7; border-color: #9333ea; color: white; font-weight: 700; } /* Using new BTN Purple */
        .next-hand-btn:hover:not(:disabled) { background-color: #9333ea; }
        /* Hand Range Chart Styles */
        #handRangeChartContainer {
            display: grid;
            grid-template-columns: repeat(13, minmax(0, 1fr));
            gap: 2px;
            background-color: #2d3748;
            padding: 0.5rem;
            border-radius: 0.5rem;
            width: 100%;
            aspect-ratio: 1 / 1;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            margin-bottom: 1rem;
         }
        .hand-cell {
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #4a5568; /* Default for unanswered */
            color: #e2e8f0;
            font-size: clamp(0.5rem, 2.2vw, 0.85rem);
            font-weight: 600;
            border-radius: 0.25rem;
            aspect-ratio: 1 / 1;
            transition: background-color 0.3s ease, box-shadow 0.3s ease, border 0.3s ease;
            cursor: pointer;
            border: 1px solid #2d3748;
         }
        .hand-cell:hover {
            border-color: #63b3ed;
         }
        .hand-cell.current-hand-highlight {
            animation: glow 1.2s infinite alternate;
            border: 2px solid #facc15; /* Tailwind yellow-400 */
        }
        .hand-cell.current-hand-highlight:hover {
            border-color: #facc15;
         }
        @keyframes glow {
            from { box-shadow: 0 0 3px #facc15, 0 0 6px #facc15, 0 0 9px #eab308, 0 0 12px #eab308; }
            to { box-shadow: 0 0 6px #facc15, 0 0 9px #facc15, 0 0 12px #ca8a04, 0 0 15px #ca8a04; }
        }
        /* Updated Chart Cell Colors */
        .hand-cell.pos-utg { background-color: #dc2626; border-color: #b91c1c; color: white; } /* Red */
        .hand-cell.pos-utgplus1 { background-color: #f97316; border-color: #ea580c; color: white; } /* Orange */
        .hand-cell.pos-mp { background-color: #eab308; border-color: #ca8a04; color: #1a202c; } /* Yellow */
        .hand-cell.pos-hj { background-color: #22c55e; border-color: #16a34a; color: white; } /* Green */
        .hand-cell.pos-co { background-color: #0ea5e9; border-color: #0284c7; color: white; } /* Sky Blue */
        .hand-cell.pos-btn { background-color: #a855f7; border-color: #9333ea; color: white; } /* Purple */
        .hand-cell.pos-fold { background-color: #6b7280; border-color: #4b5563; color: white; } /* Gray */

        .legend {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.5rem;
            margin-top: 0.5rem;
            padding: 0.5rem;
            background-color: #2d3748;
            border-radius: 0.5rem;
            width: 100%;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
        }
        .legend-color-box {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            border: 1px solid rgba(0,0,0,0.2);
        }
    </style>
</head>
<body class="flex flex-col items-center min-h-screen">
    <div class="w-full max-w-6xl mx-auto px-4">
        <h1 class="text-3xl font-bold mb-2 text-sky-400 text-center">ポーカー オープンポジション クイズ (40bb)</h1>
        <p class="text-center text-sky-200 mb-6 text-sm">全てのハンド (UTGオープン、各ポジションでのオープン、フォールド) がクイズ対象です。</p>

        <div class="main-container">
            <div class="quiz-panel-container">
                <div id="handRangeChartContainer">
                    </div>
                <div id="legendContainer" class="legend">
                    </div>
            </div>

            <div class="quiz-panel-container">
                <div id="quizPanel" class="quiz-panel">
                    <h2 class="text-xl font-semibold mb-4 text-sky-300">ポジションクイズ</h2>
                    <div class="my-6 p-4 bg-gray-700 rounded-lg shadow-inner">
                        <p class="text-sm mb-1 text-gray-400">現在のハンド:</p>
                        <div id="handDisplay" class="card-display">--</div>
                    </div>
                    <div id="actionButtonsContainer" class="flex flex-wrap justify-center gap-2 mb-4">
                        <button id="btnUTG" class="btn-action btn-pos-utg">UTG</button>
                        <button id="btnUTGPlus1" class="btn-action btn-pos-utgplus1">UTG+1</button>
                        <button id="btnMP" class="btn-action btn-pos-mp">MP</button>
                        <button id="btnHJ" class="btn-action btn-pos-hj">HJ</button>
                        <button id="btnCO" class="btn-action btn-pos-co">CO</button>
                        <button id="btnBTN" class="btn-action btn-pos-btn">BTN</button>
                        <button id="btnFOLD" class="btn-action btn-pos-fold">FOLD</button>
                    </div>
                    <div id="feedbackArea" class="min-h-[3em] text-md font-semibold mb-4"></div>
                    <div class="score-board mb-4 text-lg">
                        <p>スコア: <span id="correctCount">0</span>/<span id="totalAttempts">0</span> (<span id="accuracy">0</span>%)</p>
                        <p>連続正解: <span id="streakCount">0</span></p>
                        <p>残り: <span id="remainingCount">0</span> 問</p>
                    </div>
                    <button id="nextHandButton" class="w-full btn-action next-hand-btn mb-2" style="display: none;">次のハンド</button>
                    <button id="resetButton" class="w-full btn-action btn-reset mb-2">リセット</button>
                    <button id="revealAllButton" class="w-full btn-action btn-reveal-all">全解放</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- 定数定義 ---
        const POSITIONS = {
            UTG: "UTG",        // Red
            UTG1: "UTG+1",     // Orange
            MP: "MP",          // Yellow
            HJ: "HJ",          // Green
            CO: "CO",          // Sky Blue
            BTN: "BTN",        // Purple
            FOLD: "FOLD"       // Gray
        };

        const BUTTON_ACTIONS = [POSITIONS.UTG, POSITIONS.UTG1, POSITIONS.MP, POSITIONS.HJ, POSITIONS.CO, POSITIONS.BTN, POSITIONS.FOLD];
        const AUTO_NEXT_DELAY = 700; // Milliseconds for auto-advancing after correct answer

        const originalHandChartUTG_RaiseFold = {
            "AA": "RAISE 2.3", "KK": "RAISE 2.3", "QQ": "RAISE 2.3", "JJ": "RAISE 2.3", "TT": "RAISE 2.3",
            "99": "RAISE 2.3", "88": "RAISE 2.3", "77": "RAISE 2.3", "66": "RAISE 2.3", "55": "RAISE 2.3",
            "44": "FOLD", "33": "FOLD", "22": "FOLD",
            "AKs": "RAISE 2.3", "AQs": "RAISE 2.3", "AJs": "RAISE 2.3", "ATs": "RAISE 2.3", "A9s": "RAISE 2.3",
            "A8s": "RAISE 2.3", "A7s": "RAISE 2.3", "A6s": "RAISE 2.3", "A5s": "RAISE 2.3", "A4s": "RAISE 2.3",
            "A3s": "RAISE 2.3", "A2s": "RAISE 2.3",
            "KQs": "RAISE 2.3", "KJs": "RAISE 2.3", "KTs": "RAISE 2.3",
            "K9s": "RAISE 2.3", "K8s": "RAISE 2.3", "K7s": "RAISE 2.3", "K6s": "FOLD", "K5s": "FOLD",
            "K4s": "FOLD", "K3s": "FOLD", "K2s": "FOLD",
            "QJs": "RAISE 2.3", "QTs": "RAISE 2.3",
            "Q9s": "RAISE 2.3", "Q8s": "FOLD",
            "Q7s": "FOLD", "Q6s": "FOLD", "Q5s": "FOLD", "Q4s": "FOLD", "Q3s": "FOLD", "Q2s": "FOLD",
            "JTs": "RAISE 2.3", "J9s": "RAISE 2.3",
            "J8s": "FOLD",
            "J7s": "FOLD", "J6s": "FOLD", "J5s": "FOLD", "J4s": "FOLD", "J3s": "FOLD", "J2s": "FOLD",
            "T9s": "RAISE 2.3", "T8s": "RAISE 2.3",
            "T7s": "FOLD", "T6s": "FOLD", "T5s": "FOLD", "T4s": "FOLD", "T3s": "FOLD", "T2s": "FOLD",
            "98s": "RAISE 2.3",
            "97s": "FOLD", "96s": "FOLD", "95s": "FOLD", "94s": "FOLD", "93s": "FOLD", "92s": "FOLD",
            "87s": "RAISE 2.3",
            "86s": "FOLD", "85s": "FOLD", "84s": "FOLD", "83s": "FOLD", "82s": "FOLD",
            "76s": "RAISE 2.3",
            "75s": "FOLD", "74s": "FOLD", "73s": "FOLD", "72s": "FOLD",
            "65s": "FOLD",
            "64s": "FOLD", "63s": "FOLD", "62s": "FOLD",
            "54s": "FOLD",
            "53s": "FOLD", "52s": "FOLD",
            "43s": "FOLD", "42s": "FOLD",
            "32s": "FOLD",
            "AKo": "RAISE 2.3", "AQo": "RAISE 2.3", "AJo": "RAISE 2.3", "ATo": "RAISE 2.3", "A9o": "FOLD", "A8o": "FOLD",
            "A7o": "FOLD", "A6o": "FOLD", "A5o": "FOLD", "A4o": "FOLD", "A3o": "FOLD", "A2o": "FOLD",
            "KQo": "RAISE 2.3", "KJo": "RAISE 2.3", "KTo": "RAISE 2.3",
            "K9o": "FOLD", "K8o": "FOLD", "K7o": "FOLD", "K6o": "FOLD", "K5o": "FOLD", "K4o": "FOLD", "K3o": "FOLD", "K2o": "FOLD",
            "QJo": "RAISE 2.3", "QTo": "FOLD",
            "Q9o": "FOLD", "Q8o": "FOLD", "Q7o": "FOLD", "Q6o": "FOLD", "Q5o": "FOLD", "Q4o": "FOLD", "Q3o": "FOLD", "Q2o": "FOLD",
            "JTo": "FOLD",
            "J9o": "FOLD", "J8o": "FOLD", "J7o": "FOLD", "J6o": "FOLD", "J5o": "FOLD", "J4o": "FOLD", "J3o": "FOLD", "J2o": "FOLD",
            "T9o": "FOLD", "T8o": "FOLD", "T7o": "FOLD", "T6o": "FOLD", "T5o": "FOLD", "T4o": "FOLD", "T3o": "FOLD", "T2o": "FOLD",
            "98o": "FOLD", "97o": "FOLD", "96o": "FOLD", "95o": "FOLD", "94o": "FOLD", "93o": "FOLD", "92o": "FOLD",
            "87o": "FOLD", "86o": "FOLD", "85o": "FOLD", "84o": "FOLD", "83o": "FOLD", "82o": "FOLD",
            "76o": "FOLD", "75o": "FOLD", "74o": "FOLD", "73o": "FOLD", "72o": "FOLD",
            "65o": "FOLD", "64o": "FOLD", "63o": "FOLD", "62o": "FOLD",
            "54o": "FOLD", "53o": "FOLD", "52o": "FOLD",
            "43o": "FOLD", "42o": "FOLD",
            "32o": "FOLD"
        };
        const ranks = ['A', 'K', 'Q', 'J', 'T', '9', '8', '7', '6', '5', '4', '3', '2'];

        const utg_opens = new Set(
            Object.keys(originalHandChartUTG_RaiseFold)
                  .filter(h => originalHandChartUTG_RaiseFold[h].startsWith("RAISE"))
        );
        const utg1_opens_additional = new Set(["44", "K6s", "QTo", "A9o", "65s", "J8s", "Q8s"]);
        const mp_opens_additional = new Set(["K5s", "T7s", "97s", "86s", "JTo", "A8o"]);
        const hj_opens_additional = new Set(["33", "K4s", "K3s", "Q7s", "Q6s", "Q5s", "J7s", "96s","54s", "A7o", "T9o"]);
        const co_opens_additional = new Set([
            "22", "K2s", "Q4s", "Q3s", "J6s", "J5s", "T6s", "85s", "75s", "64s", "63s",
            "A6o", "A5o", "A4o", "K9o","K8o", "Q9o", "J9o", "T8o"
        ]);
        const btn_opens_additional = new Set([
            "J3s", "J2s", "T3s","Q8o","Q7o","J8o","98o","T7o","87o","97o","Q2s", "J4s",
            "T5s", "T4s","95s",  "84s", "74s","53s", "A3o", "A2o","K7o", "K6o", "K5o",
        ]);

        const positionalHandChart = {};
        const all169Hands = [];
        for (let i = 0; i < ranks.length; i++) {
            for (let j = 0; j < ranks.length; j++) {
                const r1 = ranks[i];
                const r2 = ranks[j];
                let hand;
                if (i === j) {
                     hand = r1 + r2;
                } else if (i < j) {
                     hand = r1 + r2 + 's';
                } else {
                     hand = r2 + r1 + 'o';
                }
                if (!all169Hands.includes(hand)) {
                     all169Hands.push(hand);
                }
            }
        }

        all169Hands.forEach(hand => {
            if (utg_opens.has(hand)) {
                positionalHandChart[hand] = POSITIONS.UTG;
            } else if (utg1_opens_additional.has(hand)) {
                positionalHandChart[hand] = POSITIONS.UTG1;
            } else if (mp_opens_additional.has(hand)) {
                positionalHandChart[hand] = POSITIONS.MP;
            } else if (hj_opens_additional.has(hand)) {
                positionalHandChart[hand] = POSITIONS.HJ;
            } else if (co_opens_additional.has(hand)) {
                positionalHandChart[hand] = POSITIONS.CO;
            } else if (btn_opens_additional.has(hand)) {
                positionalHandChart[hand] = POSITIONS.BTN;
            } else {
                // Check if it's an UTG open that wasn't caught by the simple utg_opens set (if any edge cases)
                // Or, more simply, if it's in originalHandChartUTG_RaiseFold and is a RAISE, it's UTG.
                // Otherwise, it's a FOLD.
                const utgAction = originalHandChartUTG_RaiseFold[hand];
                if (utgAction && utgAction.startsWith("RAISE")) {
                     positionalHandChart[hand] = POSITIONS.UTG; // Should be covered by utg_opens but as a fallback
                } else {
                     positionalHandChart[hand] = POSITIONS.FOLD;
                }
            }
        });

        const quizPool = [...all169Hands];

        const handRangeChartContainer = document.getElementById('handRangeChartContainer');
        const handCellElements = {};

        function getHandCellClass(position) {
            switch (position) {
                case POSITIONS.UTG: return 'pos-utg';
                case POSITIONS.UTG1: return 'pos-utgplus1';
                case POSITIONS.MP: return 'pos-mp';
                case POSITIONS.HJ: return 'pos-hj';
                case POSITIONS.CO: return 'pos-co';
                case POSITIONS.BTN: return 'pos-btn';
                case POSITIONS.FOLD: return 'pos-fold';
                default: return '';
            }
        }

        function generateHandRangeChart() {
            handRangeChartContainer.innerHTML = '';
            for (let i = 0; i < ranks.length; i++) {
                for (let j = 0; j < ranks.length; j++) {
                    const r1 = ranks[i];
                    const r2 = ranks[j];
                    let hand;
                    if (i === j) {
                         hand = r1 + r2;
                    } else if (i < j) {
                         hand = r1 + r2 + 's';
                    } else {
                         hand = r2 + r1 + 'o';
                    }

                    const cell = document.createElement('div');
                    cell.classList.add('hand-cell');
                    cell.textContent = hand;
                    cell.dataset.hand = hand;
                    handCellElements[hand] = cell;

                    cell.addEventListener('mousedown', (event) => {
                        event.preventDefault();
                        quizInstance.isDragging = true;
                        quizInstance.handleChartCellClick(hand);
                        quizInstance.lastDraggedCell = cell;
                    });
                    cell.addEventListener('mouseenter', (event) => {
                         if (quizInstance.isDragging) {
                            if (cell !== quizInstance.lastDraggedCell) {
                                quizInstance.handleChartCellClick(hand);
                                quizInstance.lastDraggedCell = cell;
                            }
                        }
                    });
                    cell.addEventListener('touchstart', (event) => {
                        event.preventDefault();
                        quizInstance.isDragging = true;
                        quizInstance.handleChartCellClick(hand);
                        quizInstance.lastDraggedCell = cell;
                    }, { passive: false });

                    cell.addEventListener('touchmove', (event) => {
                        event.preventDefault();
                        if (quizInstance.isDragging) {
                            const touch = event.touches[0];
                            const targetElement = document.elementFromPoint(touch.clientX, touch.clientY);
                            if (targetElement && targetElement.classList.contains('hand-cell')) {
                                const touchedHand = targetElement.dataset.hand;
                                if (targetElement !== quizInstance.lastDraggedCell) {
                                     quizInstance.handleChartCellClick(touchedHand);
                                     quizInstance.lastDraggedCell = targetElement;
                                }
                            }
                        }
                    }, { passive: false });

                    handRangeChartContainer.appendChild(cell);
                }
            }
        }

        function generateLegend() {
            const legendContainer = document.getElementById('legendContainer');
            legendContainer.innerHTML = '';
            const legendPositions = [POSITIONS.UTG, POSITIONS.UTG1, POSITIONS.MP, POSITIONS.HJ, POSITIONS.CO, POSITIONS.BTN, POSITIONS.FOLD];
            legendPositions.forEach(pos => {
                const item = document.createElement('div');
                item.classList.add('legend-item');
                const colorBox = document.createElement('div');
                colorBox.classList.add('legend-color-box');
                colorBox.classList.add(getHandCellClass(pos));
                const text = document.createElement('span');
                text.textContent = pos;
                item.appendChild(colorBox);
                item.appendChild(text);
                legendContainer.appendChild(item);
            });
        }

        let quizInstance = null;

        class Quiz {
            constructor(initialHandPool) {
                this.allHandsInPool = [...initialHandPool];
                this.remainingHands = [...initialHandPool];
                this.isDragging = false;
                this.lastDraggedCell = null;

                this.dom = {
                    handDisplay: document.getElementById('handDisplay'),
                    feedbackArea: document.getElementById('feedbackArea'),
                    correctCount: document.getElementById('correctCount'),
                    totalAttempts: document.getElementById('totalAttempts'),
                    accuracy: document.getElementById('accuracy'),
                    streakCount: document.getElementById('streakCount'),
                    remainingCount: document.getElementById('remainingCount'),
                    nextHandButton: document.getElementById('nextHandButton'),
                    resetButton: document.getElementById('resetButton'),
                    revealAllButton: document.getElementById('revealAllButton'),
                    actionButtons: []
                };

                this.currentHand = '';
                this.currentCorrectAction = '';
                this.correctAnswers = 0;
                this.totalAttempts = 0;
                this.currentStreak = 0;
                this.autoNextTimeout = null;
                this.quizOver = false;

                this.initEventListeners();
                this.resetChartStyles();
                this.updateScoreDisplay();
                this.displayNewHand();
            }

            initEventListeners() {
                BUTTON_ACTIONS.forEach(action => {
                    const buttonIdSuffix = action.replace('+', 'Plus');
                    const buttonElement = document.getElementById(`btn${buttonIdSuffix}`);
                    if (buttonElement) {
                        buttonElement.addEventListener('click', () => this.handleAction(action));
                        this.dom.actionButtons.push(buttonElement);
                    } else {
                        console.warn(`Button with ID btn${buttonIdSuffix} not found.`);
                    }
                });

                this.dom.nextHandButton.addEventListener('click', () => {
                    clearTimeout(this.autoNextTimeout);
                    this.displayNewHand();
                });
                this.dom.resetButton.addEventListener('click', () => this.resetQuiz());
                this.dom.revealAllButton.addEventListener('click', () => this.revealAllHands());

                document.addEventListener('mouseup', () => {
                    if (this.isDragging) {
                        this.isDragging = false;
                        this.lastDraggedCell = null;
                    }
                });
                document.addEventListener('touchend', () => {
                    if (this.isDragging) {
                        this.isDragging = false;
                        this.lastDraggedCell = null;
                    }
                });
            }

            resetChartStyles() {
                Object.values(handCellElements).forEach(cell => {
                    cell.className = 'hand-cell';
                });
            }

            getRandomHand() {
                if (this.remainingHands.length === 0) return null;
                const randomIndex = Math.floor(Math.random() * this.remainingHands.length);
                return this.remainingHands[randomIndex];
            }

            updateScoreDisplay() {
                this.dom.correctCount.textContent = this.correctAnswers;
                this.dom.totalAttempts.textContent = this.totalAttempts;
                this.dom.streakCount.textContent = this.currentStreak;
                const accuracyValue = this.totalAttempts > 0 ? ((this.correctAnswers / this.totalAttempts) * 100).toFixed(1) : 0;
                this.dom.accuracy.textContent = accuracyValue;
                this.dom.remainingCount.textContent = this.remainingHands.length;
            }

            updateScoreState(isCorrectAttempt, clickedHand = null) {
                this.totalAttempts++;
                if (isCorrectAttempt) {
                    this.correctAnswers++;
                    if (clickedHand === null || clickedHand === this.currentHand) {
                          this.currentStreak++;
                    }
                } else {
                     if (clickedHand === null || clickedHand === this.currentHand) {
                         this.currentStreak = 0;
                     }
                }
                this.updateScoreDisplay();
            }

            highlightCurrentHandOnChart() {
                const currentlyHighlighted = handRangeChartContainer.querySelector('.current-hand-highlight');
                if (currentlyHighlighted) {
                    currentlyHighlighted.classList.remove('current-hand-highlight');
                }
                if (this.currentHand && handCellElements[this.currentHand] && this.remainingHands.includes(this.currentHand)) {
                    handCellElements[this.currentHand].classList.add('current-hand-highlight');
                }
            }

            // Method to generate HTML for card display
            generateCardDisplayHTML(handString) {
                if (!handString || handString.length < 2) return '--';

                const rankSymbols = { 'A': 'A', 'K': 'K', 'Q': 'Q', 'J': 'J', 'T': '10' };
                // Ranks '9' through '2' will use their own character

                let r1 = handString[0];
                let r2 = handString[1];
                let type = handString.length > 2 ? handString[2] : ''; // 's', 'o', or empty for pair

                let card1RankDisplay = rankSymbols[r1] || r1;
                let card2RankDisplay = rankSymbols[r2] || r2;

                let card1SuitChar, card2SuitChar;
                let card1ColorClass, card2ColorClass;

                const suitDetails = [
                    { char: '♠', colorClass: 'text-gray-800' }, // Using gray-800 for better visibility on white
                    { char: '♥', colorClass: 'text-red-600' },
                    { char: '♦', colorClass: 'text-red-600' },
                    { char: '♣', colorClass: 'text-gray-800' }
                ];
                
                // Shuffle suits for variety in 's' and 'o' display
                const shuffledSuitDetails = [...suitDetails].sort(() => 0.5 - Math.random());

                if (r1 === r2) { // Pair
                    card1SuitChar = shuffledSuitDetails[0].char;
                    card1ColorClass = shuffledSuitDetails[0].colorClass;
                    // Ensure the second suit is different for a pair for visual variety
                    card2SuitChar = shuffledSuitDetails[1].char;
                    card2ColorClass = shuffledSuitDetails[1].colorClass;
                } else if (type === 's') { // Suited
                    const chosenSuit = shuffledSuitDetails[0];
                    card1SuitChar = chosenSuit.char;
                    card2SuitChar = chosenSuit.char;
                    card1ColorClass = chosenSuit.colorClass;
                    card2ColorClass = chosenSuit.colorClass;
                } else { // Offsuit (type === 'o' or implied)
                    card1SuitChar = shuffledSuitDetails[0].char;
                    card1ColorClass = shuffledSuitDetails[0].colorClass;
                    card2SuitChar = shuffledSuitDetails[1].char; // Will be different from first
                    card2ColorClass = shuffledSuitDetails[1].colorClass;
                }

                const cardBaseStyle = "inline-block bg-white rounded-md shadow-md mx-1 p-1 w-[4.5rem] h-[6rem] text-center relative"; // Adjusted size slightly
                const rankStyle = "block text-3xl font-bold mt-3"; // Adjusted margin
                const suitStyleTop = "block text-lg absolute top-1 left-1.5"; // Adjusted size & position
                const suitStyleBottom = "block text-lg absolute bottom-1 right-1.5 transform rotate-180"; // Adjusted size & position

                return `
                    <div class="flex justify-center items-center">
                        <div class="${cardBaseStyle}">
                            <span class="${rankStyle} ${card1ColorClass}">${card1RankDisplay}</span>
                            <span class="${suitStyleTop} ${card1ColorClass}">${card1SuitChar}</span>
                            <span class="${suitStyleBottom} ${card1ColorClass}">${card1SuitChar}</span>
                        </div>
                        <div class="${cardBaseStyle}">
                            <span class="${rankStyle} ${card2ColorClass}">${card2RankDisplay}</span>
                            <span class="${suitStyleTop} ${card2ColorClass}">${card2SuitChar}</span>
                            <span class="${suitStyleBottom} ${card2ColorClass}">${card2SuitChar}</span>
                        </div>
                    </div>
                `;
            }

            displayNewHand() {
                clearTimeout(this.autoNextTimeout);

                if (this.currentHand && handCellElements[this.currentHand] && !this.remainingHands.includes(this.currentHand)) {
                    // Only remove highlight if it was for the hand that's now answered
                    const cell = handCellElements[this.currentHand];
                    if(cell) cell.classList.remove('current-hand-highlight');
                }

                this.currentHand = this.getRandomHand();
                this.updateScoreDisplay();
                this.highlightCurrentHandOnChart(); // Highlight new current hand

                if (this.quizOver) return;

                if (this.currentHand === null) {
                    this.quizOver = true;
                    this.dom.handDisplay.innerHTML = '<span class="text-2xl text-yellow-400">全問正解!</span>';
                    this.dom.feedbackArea.textContent = "おめでとうございます！リセットして再挑戦できます。";
                    this.dom.feedbackArea.className = 'min-h-[3em] text-md font-semibold mb-4 feedback-correct';
                    this.dom.actionButtons.forEach(button => {
                        button.disabled = true;
                        button.classList.add('disabled-button');
                    });
                    this.dom.nextHandButton.style.display = 'none';
                    const currentlyHighlighted = handRangeChartContainer.querySelector('.current-hand-highlight');
                    if (currentlyHighlighted) currentlyHighlighted.classList.remove('current-hand-highlight');
                    return;
                }

                this.currentCorrectAction = positionalHandChart[this.currentHand];
                if (typeof this.currentCorrectAction === 'undefined') {
                    console.error(`Error: Hand ${this.currentHand} has an undefined action.`);
                    this.remainingHands = this.remainingHands.filter(h => h !== this.currentHand); // Remove problematic hand
                    this.displayNewHand(); // Try to get another hand
                    return;
                }

                this.dom.handDisplay.innerHTML = this.generateCardDisplayHTML(this.currentHand); // Use new card display

                this.dom.feedbackArea.textContent = '';
                this.dom.feedbackArea.className = 'min-h-[3em] text-md font-semibold mb-4';
                this.dom.actionButtons.forEach(button => {
                    button.disabled = false;
                    button.classList.remove('disabled-button');
                });
                this.dom.nextHandButton.style.display = 'none';
            }

            handleAction(chosenPosition) {
                if (this.quizOver || !this.currentHand) return;

                clearTimeout(this.autoNextTimeout);
                this.dom.actionButtons.forEach(button => {
                    button.disabled = true;
                    button.classList.add('disabled-button');
                });

                const isCorrect = chosenPosition === this.currentCorrectAction;
                this.updateScoreState(isCorrect);

                const currentCell = handCellElements[this.currentHand];
                if (currentCell) {
                    currentCell.classList.remove('current-hand-highlight'); // Remove highlight after answering
                    currentCell.className = 'hand-cell'; // Reset classes
                    currentCell.classList.add(getHandCellClass(this.currentCorrectAction)); // Show correct action on chart
                }

                if (isCorrect) {
                    this.dom.feedbackArea.textContent = `正解！ ${this.currentHand} は ${this.currentCorrectAction}。`;
                    this.dom.feedbackArea.className = 'min-h-[3em] text-md font-semibold mb-4 feedback-correct';

                    const handIndex = this.remainingHands.indexOf(this.currentHand);
                    if (handIndex > -1) {
                        this.remainingHands.splice(handIndex, 1);
                    }
                    this.updateScoreDisplay();

                    if (this.remainingHands.length === 0) {
                        this.displayNewHand(); // This will trigger the "All correct" message
                    } else {
                        this.autoNextTimeout = setTimeout(() => {
                            this.displayNewHand();
                        }, AUTO_NEXT_DELAY);
                    }
                } else {
                    this.dom.feedbackArea.textContent = `不正解。選択: ${chosenPosition}。正解は ${this.currentCorrectAction} (${this.currentHand})。`;
                    this.dom.feedbackArea.className = 'min-h-[3em] text-md font-semibold mb-4 feedback-incorrect';
                    this.dom.nextHandButton.style.display = 'block';
                }
            }

            handleChartCellClick(hand) {
                if (this.quizOver) return;

                const handIndexInRemaining = this.remainingHands.indexOf(hand);
                if (handIndexInRemaining === -1) return; // Already answered or revealed

                const correctActionForClickedHand = positionalHandChart[hand];
                const cell = handCellElements[hand];

                cell.className = 'hand-cell'; // Reset classes
                cell.classList.add(getHandCellClass(correctActionForClickedHand)); // Show its correct action

                this.remainingHands.splice(handIndexInRemaining, 1);

                if (hand === this.currentHand) {
                    // Clicked the current quiz hand on the chart
                    this.updateScoreState(true, hand); // Correctly answered current hand
                    this.dom.feedbackArea.textContent = `正解！ ${this.currentHand} は ${correctActionForClickedHand} (チャートから選択)。`;
                    this.dom.feedbackArea.className = 'min-h-[3em] text-md font-semibold mb-4 feedback-correct';

                    this.dom.actionButtons.forEach(button => {
                        button.disabled = true;
                        button.classList.add('disabled-button');
                    });
                    clearTimeout(this.autoNextTimeout);
                    if (this.remainingHands.length === 0) {
                        this.displayNewHand();
                    } else {
                        this.autoNextTimeout = setTimeout(() => {
                            this.displayNewHand();
                        }, AUTO_NEXT_DELAY);
                    }
                } else {
                    // Clicked a different hand on the chart (revealing it)
                    // This counts as a correct "reveal" for that hand, not affecting current streak for quiz hand.
                    this.updateScoreState(true, hand); // Mark as correct for this specific hand
                    this.updateScoreDisplay(); // Update score, remaining count
                    // No feedback change here as it's not the main quiz hand
                }
                 if (cell.classList.contains('current-hand-highlight')) {
                    cell.classList.remove('current-hand-highlight');
                }
            }

            revealAllHands() {
                if (this.quizOver && this.remainingHands.length === 0) return;
                clearTimeout(this.autoNextTimeout);
                this.quizOver = true;

                this.allHandsInPool.forEach(hand => {
                    const correctAction = positionalHandChart[hand];
                    const cell = handCellElements[hand];
                    if (cell) {
                        cell.className = 'hand-cell';
                        cell.classList.add(getHandCellClass(correctAction));
                    }
                    // Update score for hands that were remaining and are now revealed
                    const handIndexInRemaining = this.remainingHands.indexOf(hand);
                    if (handIndexInRemaining !== -1) {
                         // Check if it wasn't already revealed by a click
                        let alreadyRevealedByColor = false;
                        POSITIONS_ARRAY = Object.values(POSITIONS);
                        for(const pos_val of POSITIONS_ARRAY){
                            if(cell.classList.contains(getHandCellClass(pos_val))){
                                alreadyRevealedByColor = true;
                                break;
                            }
                        }
                        if(!alreadyRevealedByColor){
                             // This logic for scoring on reveal all might be complex if we want to avoid double counting
                             // For simplicity, reveal all just shows the chart. Score is based on direct answers.
                        }
                    }
                });
                
                // Score update for reveal all: Let's count all remaining hands as "attempted" and "correct" for simplicity of reveal.
                // This might not be desired if "accuracy" should only reflect direct answers.
                // For now, let's just clear remaining and update display.
                // this.correctAnswers += this.remainingHands.length;
                // this.totalAttempts += this.remainingHands.length;

                this.remainingHands = [];
                this.currentStreak = 0; // Streak ends on reveal all
                this.updateScoreDisplay();

                this.dom.handDisplay.innerHTML = '<span class="text-xl text-sky-300">全解放済</span>';
                this.dom.feedbackArea.textContent = "全てのハンドが解放されました。リセットして再挑戦できます。";
                this.dom.feedbackArea.className = 'min-h-[3em] text-md font-semibold mb-4 feedback-neutral';

                this.dom.actionButtons.forEach(button => {
                    button.disabled = true;
                    button.classList.add('disabled-button');
                });
                this.dom.nextHandButton.style.display = 'none';
                const currentlyHighlighted = handRangeChartContainer.querySelector('.current-hand-highlight');
                if (currentlyHighlighted) currentlyHighlighted.classList.remove('current-hand-highlight');
                this.currentHand = null;
            }

            resetQuiz() {
                clearTimeout(this.autoNextTimeout);
                this.quizOver = false;
                this.remainingHands = [...this.allHandsInPool];
                this.correctAnswers = 0;
                this.totalAttempts = 0;
                this.currentStreak = 0;

                this.resetChartStyles(); // Clears colors from chart cells
                this.updateScoreDisplay();

                this.dom.feedbackArea.textContent = 'クイズがリセットされました。';
                this.dom.feedbackArea.className = 'min-h-[3em] text-md font-semibold mb-4 feedback-neutral';
                this.dom.actionButtons.forEach(button => {
                    button.disabled = false;
                    button.classList.remove('disabled-button');
                });
                this.dom.nextHandButton.style.display = 'none';
                this.dom.handDisplay.innerHTML = '--'; // Reset hand display

                this.autoNextTimeout = setTimeout(() => { // Delay before showing the first hand
                    this.displayNewHand();
                }, 500);
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            generateHandRangeChart();
            generateLegend();
            if (quizPool.length > 0) {
                quizInstance = new Quiz(quizPool);
            } else {
                const panel = document.getElementById('quizPanel');
                if(panel) panel.innerHTML = '<p class="text-center text-yellow-400 p-4">クイズ対象のハンドがありません。</p>';
                document.getElementById('handDisplay').textContent = "エラー";
            }
        });
    </script>
</body>
</html>
